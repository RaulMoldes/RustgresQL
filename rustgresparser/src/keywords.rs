#![allow(dead_code)]
#![allow(unused_imports)]

pub enum Symbols {
    Semicolon,
    Comma,
    LeftParenthesis,
    RightParenthesis,
    Equal,
    Plus,
    Minus,
    Asterisk,
    Slash,
    Percent,
    LessThan,
    GreaterThan,
    Not,
    Regex,
    Ampersand,
    VerticalBar,
    Tilde,
}

impl Symbols {
    pub fn as_str(&self) -> &str {
        match self {
            Symbols::Semicolon => ";",
            Symbols::Comma => ",",
            Symbols::LeftParenthesis => "(",
            Symbols::RightParenthesis => ")",
            Symbols::Equal => "=",
            Symbols::Plus => "+",
            Symbols::Minus => "-",
            Symbols::Asterisk => "*",
            Symbols::Slash => "/",
            Symbols::Percent => "%",
            Symbols::LessThan => "<",
            Symbols::GreaterThan => ">",
            Symbols::Regex => "^",
            Symbols::Not => "!",
            Symbols::Ampersand => "&",
            Symbols::VerticalBar => "|",
            Symbols::Tilde => "~",
        }
    }

    pub fn variants() -> Vec<Symbols> {
        vec![
            Symbols::Semicolon,
            Symbols::Comma,
            Symbols::LeftParenthesis,
            Symbols::RightParenthesis,
            Symbols::Equal,
            Symbols::Plus,
            Symbols::Minus,
            Symbols::Asterisk,
            Symbols::Slash,
            Symbols::Percent,
            Symbols::LessThan,
            Symbols::GreaterThan,
            Symbols::Not,
            Symbols::Regex,
            Symbols::Ampersand,
            Symbols::VerticalBar,
            Symbols::Tilde,
        ]
    }
}

pub enum LiteralDelimiter {
    SingleQuote,
    DoubleQuote,
}

impl LiteralDelimiter {
    pub fn as_str(&self) -> &str {
        match self {
            LiteralDelimiter::SingleQuote => "'",
            LiteralDelimiter::DoubleQuote => "\"",
        }
    }
    pub fn variants() -> Vec<LiteralDelimiter> {
    vec![
        LiteralDelimiter::SingleQuote,
        LiteralDelimiter::DoubleQuote,
    ]
}
}

// Macro para automatizar la creación de Keywords como structs. Cada Keyword es un struct con un solo campo con el valor en String.
// Se crea un trait Keyword con un método as_str que devuelve el valor del Keyword en String.
trait Keyword {
    fn as_str(&self) -> String;
}

// Función para convertir de camelCase a snake_case
fn to_snake_case(input: &str) -> String {
    let mut result = String::new();
    
    for (i, c) in input.chars().enumerate() {
        if c.is_uppercase() {
            // Si es la primera letra o está en medio, agregamos un guion bajo antes de la letra
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_lowercase().next().unwrap()); // Convertimos a minúsculas
        } else {
            result.push(c);
        }
    }

    result
}

// Macro que genera los structs y las implementaciones del trait.
// Necesitamos definir la macro antes de usarla
macro_rules! keyword_from_enum {
    ($enum_name:ident { $($keyword:ident),* $(,)? }) => {
        // Definición del enum con las variantes listadas
        pub enum $enum_name {
            $($keyword),*
        }

        // Generación de structs y su implementación del trait Keyword
        $(
            pub struct $keyword;

            impl Keyword for $keyword {
                fn as_str(&self) -> String {
                    let camel_case_str = stringify!($keyword);
                    let snake_case_str = to_snake_case(camel_case_str); // Llamamos a la función para convertirlo
                    snake_case_str
                }
            }
        )*

        // Implementación del trait `Keyword` para el enum
        impl $enum_name {
            pub fn as_str(&self) -> String {
                match self {
                    $( $enum_name::$keyword => {
                        let keyword_struct = $keyword;
                        keyword_struct.as_str()
                    } ),*
                }
            }

            pub fn variants() -> Vec<$enum_name> {
                vec![
                    $( $enum_name::$keyword ),*
                ]
            }
        }
    };
}





// Uso de la macro para declarar el enum y los structs correspondientes
keyword_from_enum!( Keywords {
    Abs,
    Access,
    Add,
    Admin,
    Alias,
    All,
    Alter,
    Always,
    Analyze,
    And,
    Anti,
    Any,
    Application,
    Apply,
    Archive,
    Are,
    Array,
    As,
    Asc,
    Assert,
    At,
    Atomic,
    Attach,
    Auto,
    AutoIncrement,
    Avg,
    Backward,
    Base64,
    Before,
    Begin,
    Between,
    BigDecimal,
    BigInt,
    BigNumeric,
    Binary,
    Binding,
    Bit,
    Blob,
    Block,
    Boolean,
    Both,
    Browse,
    Btree,
    By,
    Bytea,
    Bytes,
    Cache,
    Call,
    Cardinality,
    Cascade,
    Case,
    Cast,
    Catalog,
    Ceil,
    Ceiling,
    Century,
    Chain,
    Change,
    Channel,
    Char,
    Character,
    Characters,
    CharLength,
    Check,
    Clear,
    Clob,
    Clone,
    Close,
    Cluster,
    Clustered,
    Clustering,
    Coalesce,
    Collate,
    Collation,
    Collect,
    Collection,
    Column,
    Columns,
    ColumnStore,
    Comment,
    Commit,
    Committed,
    Compression,
    Concurrently,
    Condition,
    Conflict,
    Connect,
    Connection,
    Constraint,
    Contains,
    Continue,
    Copy,
    CopyOptions,
    Corresponding,
    Count,
    CovarPop,
    CovarSamp,
    Create,
    Credentials,
    Cross,
    Csv,
    Current,
    CurrentCatalog,
    CurrentDate,
    CurrentDefaultTransformGroup,
    CurrentPath,
    CurrentRole,
    CurrentRow,
    CurrentSchema,
    CurrentTime,
    CurrentTimestamp,
    CurrentTransformGroupForType,
    CurrentUser,
    Cursor,
    Cycle,
    Data,
    Database,
    Databases,
    Date,
    Date32,
    Datetime,
    Datetime64,
    Day,
    DayOfWeek,
    DayOfYear,
    Deallocate,
    Dec,
    Decade,
    Decimal,
    Declare,
    Deduplicate,
    Default,
    Deferrable,
    Deferred,
    Define,
    Defined,
    Delayed,
    Delete,
    Delimited,
    Delimiter,
    Delta,
    DenseRank,
    Deref,
    Desc,
    Describe,
    Detach,
    Detail,
    Deterministic,
    Directory,
    Disable,
    Discard,
    Disconnect,
    Distinct,
    Distribute,
    Div,
    r#Do,
    Double,
    Dow,
    Doy,
    Drop,
    Dry,
    Duplicate,
    Dynamic,
    Each,
    Element,
    Elements,
    Else,
    Empty,
    Enable,
    Encoding,
    Encryption,
    End,
    Endpoint,
    Enforced,
    Engine,
    Enum,
    Enum16,
    Enum8,
    Ephemeral,
    Epoch,
    Equals,
    Error,
    Escape,
    Escaped,
    Estimate,
    Event,
    Every,
    Except,
    Exception,
    Exec,
    Execute,
    Exists,
    Exp,
    Expansion,
    Explain,
    Explicit,
    Export,
    Extended,
    Extension,
    External,
    Extract,
    Fail,
    r#False,
    Fetch,
    Fields,
    File,
    Files,
    FileFormat,
    Fill,
    Filter,
    r#Final,
    First,
    FirstValue,
    FixedString,
    Float,
    Float32,
    Float4,
    Float64,
    Float8,
    Floor,
    Flush,
    Following,
    r#For,
    Force,
    ForceNotNull,
    ForceNull,
    ForceQuote,
    Foreign,
    Format,
    Formatted,
    Forward,
    FrameRow,
    Free,
    Freeze,
    From,
    Fsck,
    Full,
    FullText,
    Function,
    Functions,
    Fusion,
    General,
    Generate,
    Generated,
    Geography,
    Get,
    Global,
    Grant,
    Granted,
    Grants,
    Graphviz,
    Group,
    Grouping,
    Groups,
    Hash,
    Having,
    Header,
    Heap,
    HighPriority,
    History,
    HiveVar,
    Hold,
    Hosts,
    Hour,
    Hours,
    Id,
    Identity,
    If,
    Ignore,
    ILike,
    Immediate,
    r#In,
    Include,
    IncludeNullValues,
    Increment,
    Index,
    Indicator,
    Inherit,
    Initially,
    Inner,
    InOut,
    InPath,
    Input,
    InputFormat,
    Insensitive,
    Insert,
    Install,
    Instead,
    Int,
    Int128,
    Int16,
    Int2,
    Int256,
    Int32,
    Int4,
    Int64,
    Int8,
    Integer,
    Interpolate,
    Intersect,
    Intersection,
    Interval,
    Into,
    Is,
    IsoDow,
    Isolation,
    IsoWeek,
    Isoyear,
    Items,
    Jar,
    Join,
    Json,
    Jsonb,
    JsonFile,
    JsonTable,
    Julian,
    Key,
    Keys,
    Kill,
    Lag,
    Language,
    Large,
    Last,
    LastValue,
    Lateral,
    Lead,
    Leading,
    Left,
    Level,
    Like,
    LikeRegex,
    Limit,
    Lines,
    Listen,
    Ln,
    Load,
    Local,
    LocalTime,
    LocalTimestamp,
    Location,
    Lock,
    Locked,
    Login,
    Logs,
    LongBlob,
    LongText,
    LowCardinality,
    Lower,
    LowPriority,
    r#Macro,
    ManagedLocation,
    Map,
    Masking,
    r#Match,
    Matched,
    Matches,
    MatchCondition,
    MatchRecognize,
    Materialized,
    Max,
    MaxLength,
    MaxValue,
    MaxCardinality,
    Media,
    Merge,
    Method,
    Methods,
    Min,
    Minimum,
    Minute,
    Minutes,
    Modify,
    Month,
    Months,
    Multiset,
    Named,
    Nat,
    Natural,
    Nchar,
    Negative,
    Net,
    Next,
    No,
    None,
    Not,
    NotNull,
    Null,
    Nulls,
    Numeric,
    Object,
    Offset,
    On,
    Open,
    Operator,
    Options,
    Or,
    Order,
    Outer,
    Out,
    OuterApply,
    OuterJoin,
    Output,
    Overwrite,
    Partition,
    Partitioned,
    Path,
    Percent,
    PercentRank,
    Period,
    Plan,
    Point,
    Policy,
    Populate,
    Precision,
    Preconditions,
    Predicate,
    Prev,
    Primary,
    Priority,
    Privilege,
    Privileges,
    Proceed,
    Profile,
    Profiling,
    Project,
    Projection,
    Properties,
    Protect,
    Protocol,
    Publish,
    Quota,
    Random,
    Range,
    Rank,
    Read,
    Readonly,
    Real,
    Recover,
    Recursive,
    Referential,
    Reject,
    Release,
    Rename,
    Replace,
    Restart,
    Restrict,
    Result,
    r#Return,
    Returns,
    Right,
    Rollback,
    Round,
    Row,
    Rows,
    Savepoint,
    Schema,
    Scope,
    Search,
    Second,
    SecondValue,
    Select,
    Semistructured,
    SelectInto,
    Send,
    Sequence,
    Sequential,
    Session,
    Set,
    Share,
    Shift,
    Show,
    Similar,
    Simple,
    Single,
    Snapshot,
    Some,
    Source,
    Sort,
    Spatial,
    Specify,
    Sql,
    SqlState,
    Stable,
    Start,
    StartFrame,
    StartPartition,
    Statement,
    Statistics,
    Stream,
    Structure,
    Subquery,
    Substitute,
    Substring,
    Successful,
    Sum,
    r#Super,
    Surrogate,
    Symmetric,
    Table,
    Tables,
    Tablespace,
    Temp,
    Temporary,
    Text,
    Time,
    Timezone,
    To,
    Top,
    Total,
    Transform,
    Trigger,
    r#True,
    Truncate,
    Unbounded,
    r#Union,
    Unique,
    Unnest,
    Unknown,
    Unlogged,
    Update,
    Upsert,
    User,
    Using,
    Value,
    Values,
    Variance,
    View,
    Volume,
    Wait,
    Week,
    When,
    r#Where,
    r#While,
    With,
    Write,
    Year,
    Zorder,
});


pub fn all_keywords() -> Vec<String> {
    Keywords::variants().iter().map(|k| k.as_str()).collect()
}

pub fn all_symbols() -> Vec<char> {
    Symbols::variants().iter().map(|s| s.as_str().chars().next().unwrap()).collect::<Vec<char>>()
}

pub fn all_delimiters() -> Vec<char> {
    LiteralDelimiter::variants().iter().map(|s| s.as_str().chars().next().unwrap()).collect::<Vec<char>>()
}